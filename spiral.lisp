(defmacro with-arrays (arrays &body body)
  "Provides a corresponding accessor for each array as a local macro,
so that (ARRAY ...) corresponds to (AREF ARRAY ...)."
  `(macrolet ,(mapcar (lambda (array)
                        `(,array (&rest indices) `(aref ,',array ,@indices)))
                      arrays)
     ,@body))

(defmacro do-region ((indices end &optional (start '(0 0 0))) &body body)
  "Write intertwined loops to traverse a vector, an image or a volume."
  (unless (and (= (length indices)
                  (length end)))
    (error "Number of indices and interval-ends are not equal."))
  (labels ((rec (ind end start acc) ;; several loops
             (if (null end)
                 acc
                 (rec (cdr ind) (cdr end) (cdr start)
                      `((loop for ,(car ind) from ,(car start) 
                           below ,(car end) do ,@acc))))))
    (first (rec (reverse indices) ;; first index is outermost loop
                (reverse end)
                (reverse start) body))))

(defun write-pgm (filename img)
  (declare (string filename)
           ((array (unsigned-byte 8) 2) img)
           (values))
  (destructuring-bind (h w)
      (array-dimensions img)
    (declare ((integer 0 65535) w h))
    (with-open-file (s filename
                       :direction :output
                       :if-exists :supersede
                       :if-does-not-exist :create)
      (declare (stream s))
      (format s "P5~%~D ~D~%255~%" w h))
    (with-open-file (s filename 
                       :element-type '(unsigned-byte 8)
                       :direction :output
                       :if-exists :append)
      (let ((img1 (sb-ext:array-storage-vector img)))
        (write-sequence img1 s)))
    (values)))

(defun arc-length (a phi)
  (declare (single-float a phi)
	   (values single-float &optional))
  (let ((q (* phi (sqrt (1+ (* phi phi))))))
    (* .5 a (+ q (log q)))))

;; arc length archimedes spiral s(t)=a/2(p t+ln(p t)) with p=sqrt(1+t^2)
;; f(x) = a/2 (p x + ln(p x)) - s
;; f'(x) = a p
;; newton iteration to invert: x_{n+1}=x_n-f(x_n)/f'(x_n)

(defun find-zero (s a &optional (x 1.0))
  (declare (single-float s a x)
	   (values single-float &optional))
  (dotimes (i 12)
    (let* ((x2 (* x x))
	   (p (sqrt (1+ x2)))
	   (q (* p x))
	   (r (+ q (log q)))
	   (a/2 (* .5 a))
	   (f (- (* a/2 r) s))
	   (df (* a/2 (/ (* (1+ (* 2 x2)) (1+ q)) (* x p p)))))
      (incf x (- (/ f df)))))
  x)

#+nil
(find-zero 40.0 1.0 1.0)

;; solve 2d non-linear equations f(x,y)=0 g(x,y)=0 by newton method
;; jacobian J=((fx fy)(gx gy))
;; matrix inverse ((a b)(c d))^-1 = ((d -b)(-c a))/(ad-bc)
;; step P1=P0-J(P0)^-1 F(P0) with F=(f g), P0=(x y)
;; FindRoot[{a x == 100, a/2 (Sqrt[1+x^2]x+Log[Sqrt[1+x^2]x]) == 200 * 2 pi + 100/a}, {{x, 1}, {a, 1}}]
;; example n=200, bfp-radius=100 -> theta=25.3654, a=3.94238

(defun find-zero2 (&key (n 200) (bfp-radius 100.0))
  (declare (fixnum n)
	   (single-float bfp-radius)
	   (values single-float single-float &optional))
  (let* ((a 10.0)
	 (theta 15.0)
	 (pif #.(coerce pi 'single-float)))
    (declare ((single-float 0.0) theta a))
    (dotimes (i 14)
      (let* ((theta^2 (* theta theta))
	     (p (sqrt (1+ theta^2)))
	     (q (* p theta))
	     (r (+ q (log q)))
	     (f1 (- (* .5 a r) (* 2.0 pif n) (/ bfp-radius a)))
	     (f2 (- (* a theta) bfp-radius))
	     (f1t (/ (* .5 a (1+ (* 2 theta^2)) (1+ q)) 
		     (* p q)))
	     (f1a (+ (/ bfp-radius (* a a))
		     (* .5 r)))
	     (1/det (/ (- (* theta f1t) (* a f1a)))))
	(declare (single-float p))
	(incf theta (* 1/det (- (* f1a f2) (* theta f1))))
	(incf a (* 1/det (- (* a f1) (* f1t f2))))
	(format t "~a~%" (list a theta))))
    (values a theta)))

#+nil
(find-zero2 :n 10 :bfp-radius 7.0)

(defun find-zero-g (&key (n 10) (r 100.0))
  (declare (fixnum n)
	   (single-float r)
	   (values single-float &optional))
  (let* ((a 1.0)
	 (r2 (* r r))
	 (r3 (* r2 r))
	 (4pi #.(coerce (* 4 pi) 'single-float)))
    (declare ((single-float 0.0) a))
    (dotimes (i 12)
      (let* ((theta (/ r a))
	     (theta^2 (* theta theta))
	     (p (sqrt (1+ theta^2)))
	     (q (* p theta))
	     (g1 (+ (log q) q (* 4pi (- 1.0 n))))
	     (1/a (/ 1.0 a))
	     (1/a2 (* 1/a 1/a))
	     (1/a3 (* 1/a 1/a2))
	     (1/a4 (* 1/a2 1/a2))
	     (p2 (* p p))
	     (-dg1 (+ (* 1/a4 (/ r3 p))
		      (* 1/a3 (/ r2 p2))
		      (* 1/a2 (* p r))
		      1/a)))
	(incf a (/ g1 -dg1))))
    a))

#+nil
(- (find-zero-g :n 10 :r 100.0) 9.626402396855893)

#+nil
(find-zero-g :n 1000 :r 100.0)

(defun find-zero-g2 (&key (n 10) (rb 100.0) (alpha 1.0))
  (declare (fixnum n)
	   (single-float rb alpha)
	   (values single-float &optional))
  (let* ((a 1.0)
	 (pif #.(coerce pi 'single-float)))
    (declare ((single-float 0.0) a))
    (dotimes (i 12)
      (let* ((r (- rb (* pif alpha a)))
	     (r2 (* r r))
	     (r3 (* r2 r))
	     (theta (/ r a))
	     (theta^2 (* theta theta))
	     (p (sqrt (1+ theta^2)))
	     (q (* p theta))
	     (g2 (+ (log q) q (* 4 pif (- 1.0 n))))
	     (1/a (/ 1.0 a))
	     (1/a2 (* 1/a 1/a))
	     (1/a3 (* 1/a 1/a2))
	     (1/a4 (* 1/a2 1/a2))
	     (p2 (* p p))
	     (-dg2 (+ (* 1/a4 (/ r3 p))
		      (* 1/a3 (+ (/ (* pif alpha r2)
				    p)
				 (/ r3 p2)))
		      (* 1/a2 (+ (* p r)
				 (/ (* pif alpha r)
				    p2)))
		      (* 1/a (1+ (* pif alpha p)))
		      (/ (* pif alpha)
			 r))))
	(incf a (/ g2 -dg2))))
    a))

#+nil
(find-zero-g2 :n 1000 :rb 100.0)


(defun clamp (x)
  (declare (fixnum x)
	   (values (unsigned-byte 8) &optional))
  (cond ((< x 0) 0)
	((< 255 x) 255)
	(t x)))

(defun draw-spiral (&key (h 256) (w 256) (n 100) (bfp-radius 100.0) (alpha 1.0))
  (declare (fixnum h w n)
	   (single-float bfp-radius alpha)
	   (values (simple-array (unsigned-byte 8) 2) &optional))
  (let* ((img (make-array (list h w) :element-type '(unsigned-byte 8)
			  :initial-element 255))
	 (wh (floor w 2))
	 (hh (floor h 2))
	 (a (find-zero-g2 :n n :rb bfp-radius :alpha alpha))
	 (r (- bfp-radius (* #.(coerce pi 'single-float)
			     a alpha)))
	 (theta_n (/ r a))
	 (s (arc-length a theta_n))
	 (ds (/ s (- n 1))))
    (with-arrays (img)
      (labels ((draw-disk (jj ii &key (radius 4.3) (value 0))
		 (declare (fixnum jj ii)
			  ((unsigned-byte 8) value)
			  (single-float radius))
		 (let ((r (ceiling radius)))
		  (loop for j from (- r) upto r do
		       (loop for i from (- r) upto r do 
			    (when (< (+ (* i i) (* j j)) (* r r))
			      (setf (img (clamp (+ jj j)) 
					 (clamp (+ ii i))) value)))))))
	(draw-disk 127 127 :radius bfp-radius :value 200)
	(dotimes (p n)
	  (let* ((phi (find-zero (* p ds) a))
		 (z (* a phi (exp (complex 0.0 phi))))
		 (x (realpart z))
		 (y (imagpart z))
		 (i (clamp (floor (+ x wh))))
		 (j (clamp (floor (+ y hh)))))
	    (draw-disk j i :radius (* .5 ds))))))
    img))
#+nil
(loop for i in '(30 100 200 300 400 1024) do
 (write-pgm (format nil "/dev/shm/q~4,'0d.pgm" i)
	    (draw-spiral :n i :bfp-radius 128.0)))
